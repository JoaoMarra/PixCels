<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>PixCels</title>
    <style>
        body { font-family: sans-serif; margin:0; }
        .box {
            background: #fff;
            border-radius: 10px;
            padding: 10px;
        }
        .innerBox {
            background: #eee;
            border-radius: 10px;
            padding: 10px;
            color: #000;
            cursor: pointer;
            margin-bottom: 5px;
            display: flex;
        }
        .innerBox.selected {
            background: #088cff;
            color: #fff;
        }
        .colorBox {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            border-style: solid;
            border-color: #000;
            border-width: 1px;
            cursor: pointer;
        }
        .colorBox.selected {
            border-color: #088cff;
            border-width: 2px;
        }
        small {
            font-size: 10px;
        }
        button {
            cursor: pointer;
        }
        .title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div style="position: relative;">
        <canvas id="canvas" style="background:black; cursor:pointer;"></canvas>
        <div style="position: absolute;top: 20px;right: 10px; display: flex;">
            <div class="box" style="width: 100px;margin-right: 10px;">
                <button onclick="addColor()" style="margin-bottom: 5px;">
                    New color
                </button>
                <div style="display:flex;justify-content: space-between; font-size: 8px;margin-bottom: 4px;">
                    <div>< Q</div><div>W ></div>
                </div>
                <div id="color_div" style="display: flex;flex-wrap: wrap;">
                </div>
            </div>
            <div class="box" style="min-width: 100px;">
                <button onclick="addLayer()" style="margin-bottom: 5px;">
                    New layer
                </button>
                <div style="display: flex;">
                    <div style="font-size: 8px; margin-right: 8px;">
                        <div style="transform: rotate(90deg);"> < </div>
                        <div style="margin-bottom:10px;">E</div>
                        <div>D</div>
                        <div style="transform: rotate(90deg);"> > </div>
                    </div>
                    <div id="layer_div">
                    </div>
                </div>
            </div>
        </div>
        <div  style="position: absolute;left: 10px; top: 20px;">
            <div class="box" style="margin-bottom:10px;display:flex;flex-direction: column;">
                <div class="title">Image data</div>
                <small>Image size</small>
                <input id="image_size_input" value="50" type="number" placeholder="Image size" onchange="imageSizeChanged(this.value)" style="margin-bottom:6px;">

                <small>Dot size</small>
                <input id="size_input" value="2" type="number" placeholder="Dot size" onchange="dotSizeChanged(this.value)" style="">
                <div style="display:flex;justify-content: space-between;font-size: 8px;margin-bottom:6px;">
                    <div>< A</div><div>S ></div>
                </div>
                <button onclick="savePNG()" style="margin-top:10px">Save as PNG</button>
            </div>
            <div class="box" style="margin-bottom:10px;">
                <div class="title">Virtual layer data</div>
                <small>Layer offset</small>
                <div style="display: flex;">
                    <div style="margin-right: 6px;">
                        <small>x</small>
                        <input id="layer_x" type="number" style="width: 50px;" onchange="moveLayer()">
                    </div>
                    <div style="margin-right:6px;">
                        <small>y</small>
                        <input id="layer_y" type="number" style="width: 50px;" onchange="moveLayer()">
                    </div>
                    <button onclick="centerH()" title="Center horizontal">cH</button>
                    <button onclick="centerV()" title="Center vertical">cV</button>
                </div>

                <small>Virtual layer size (500x500)</small>
                <div style="display: flex;">
                    <div style="margin-right: 6px;">
                        <small>width</small>
                        <input id="layer_w" type="number" style="width: 50px;" onchange="resizeLayerW()" min="1">
                    </div>
                    <div style="margin-right: 6px;">
                        <small>height</small>
                        <input id="layer_h" type="number" style="width: 50px;" onchange="resizeLayerH()">
                    </div>
                    <button id="layer_wh" onclick="toggleLayerWH()" title="Block/Unblock keep original size ratio">B</button>
                </div>
                <button onclick="uploadImage()" style="margin-top:10px">Upload image</button>
            </div>
        </div>
    </div>
</body>
<script>
    const canvas = document.getElementById("canvas");
    const canvasCtx = canvas.getContext("2d");
    const DRAW_SIZE = 500;

    var P_SIZE = 50;
    var DOT_SIZE = 2;

    var START_X;
    var START_Y;
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        START_X = canvas.width/2-DRAW_SIZE/2;
        START_Y = canvas.height/2-DRAW_SIZE/2;
    }
    window.addEventListener("resize", resize);
    resize();

    const layerDiv = document.getElementById("layer_div");
    const colorDiv = document.getElementById("color_div");
    const sizeInput = document.getElementById("size_input");
    DOT_SIZE = parseInt(sizeInput.value);

    function dotSizeChanged(value) {
        DOT_SIZE = parseInt(Math.floor(Math.max(1,Math.min(value, P_SIZE/2))));
        drawCanvas();

        sizeInput.value = DOT_SIZE;
    }

    function imageSizeChanged(value) {
        P_SIZE = parseInt(Math.floor(Math.max(56,value)));
        drawCanvas();
    }

    const layerX = document.getElementById("layer_x");
    const layerY = document.getElementById("layer_y");

    function moveLayer(x=null,y=null) {
        if(x == null) {
            x = parseInt(layerX.value);
        } else {
            layerX.value = x;
        }
        if(y == null) {
            y = parseInt(layerY.value);
        } else {
            layerY.value = y;
        }
        LAYERS[CURRENT_LAYER].x = x;
        LAYERS[CURRENT_LAYER].y = y;

        drawCanvas();
    }

    const layerW = document.getElementById("layer_w");
    const layerH = document.getElementById("layer_h");

    function resizeLayerW(){
        resizeLayer(parseInt(layerW.value),null);
    }
    function resizeLayerH(){
        resizeLayer(null,parseInt(layerH.value));
    }

    function resizeLayer(w=null,h=null) {
        if(isNaN(w) || isNaN(h))
            return;
        if(w == null) {
            if(LAYERS[CURRENT_LAYER].blockWH) {
                w = h*LAYERS[CURRENT_LAYER].ow/LAYERS[CURRENT_LAYER].oh;
                layerW.value = w;
            } else {
                w = parseInt(layerW.value);
            }
        } else {
            layerW.value = w;
        }
        if(h == null) {
            if(LAYERS[CURRENT_LAYER].blockWH) {
                h = w*LAYERS[CURRENT_LAYER].oh/LAYERS[CURRENT_LAYER].ow;
                layerH.value = h;
            } else {
                h = parseInt(layerH.value);
            }
        } else {
            layerH.value = h;
        }
        LAYERS[CURRENT_LAYER].w = w;
        LAYERS[CURRENT_LAYER].h = h;

        drawCanvas();
    }

    const layerWH = document.getElementById("layer_wh");

    function toggleLayerWH() {
        LAYERS[CURRENT_LAYER].blockWH = !LAYERS[CURRENT_LAYER].blockWH;
        if(LAYERS[CURRENT_LAYER].blockWH) {
            layerWH.innerHTML = "B";
            resizeLayer(LAYERS[CURRENT_LAYER].w,null);
        } else {
            layerWH.innerHTML = "U";
        }
    }

    function centerH() {
        LAYERS[CURRENT_LAYER].x = (DRAW_SIZE/2-LAYERS[CURRENT_LAYER].w/2);
        layerX.value = LAYERS[CURRENT_LAYER].x;

        drawCanvas();
    }
    function centerV() {
        LAYERS[CURRENT_LAYER].y = (DRAW_SIZE/2-LAYERS[CURRENT_LAYER].h/2);
        layerY.value = LAYERS[CURRENT_LAYER].y;

        drawCanvas();
    }

    function rewind() {
        if(LAYERS[CURRENT_LAYER].commands.length > 0) {
            let cmd = LAYERS[CURRENT_LAYER].commands.splice(LAYERS[CURRENT_LAYER].commands.length-1,1)[0];
            delete LAYERS[CURRENT_LAYER].map[cmd[0]];
            drawCanvas();
        }
    }
</script>
<script>
    var LAYERS = [
    ];
    LAYERS.push(newLayer());
    var CURRENT_LAYER = 0;
    var COLORS = [
        "#000",
        "#fff",
        "#eee",
        "#f00",
        "#0f0",
        "#00f",
        "#2b0000",
        "#5a0000",
        "#8f0000",
        "#c42020",
        "#ff4a4a",
        "#ff7a7a",
        "#ffb0b0",
        "#ffd6d6",
        "#fff0f0",

        "#002b00",
        "#005a00",
        "#008f00",
        "#20c420",
        "#4aff4a",
        "#7aff7a",
        "#b0ffb0",
        "#d6ffd6",
        "#f0fff0",

        "#00002b",
        "#00005a",
        "#00008f",
        "#2020c4",
        "#4a4aff",
        "#7a7aff",
        "#b0b0ff",
        "#d6d6ff",
        "#f0f0ff",

    ];
    var CURRENT_COLOR = 0;

    function newLayer(name=null,content=null) {
        let width = DRAW_SIZE;
        let height = DRAW_SIZE;
        if(content != null) {
            width = content.width;
            height = content.height;

            if(name == null) {
                name = `Image ${LAYERS.length}`;
            }
        } else {
            if(name == null) {
                name = `Layer ${LAYERS.length}`;
            }
        }
        return {
            'name':name,
            'x':0,
            'y':0,
            'w':width,
            'h':height,
            'ow':width,
            'oh':height,
            'commands':[],
            'map':{},
            'showing':true,
            'content':content,
            'blockWH':true
        }
    }

    function addLayer(content=null) {
        LAYERS.push(newLayer(null,content));
        refreshLayer();
        layerSelected(LAYERS.length-1);
    }

    function toggleLayer(l) {
        LAYERS[l].showing = !LAYERS[l].showing;
        refreshLayer();

        drawCanvas();
    }

    function refreshLayer() {
        buildLayerDiv();
        layerSelected(CURRENT_LAYER);
    }

    function buildLayerDiv() {
        let html = "";
        LAYERS.forEach((l,i)=>{
            html += `<div id="layer_${i}" class="innerBox" onclick="layerSelected(${i})">
            <span>${l.name}</span>
            <button onclick="event.stopPropagation();toggleLayer(${i})" title="Show/Hide layer" style="margin-left:4px;margin-right:4px;">${l.showing?'H':'S'}</button>`
            if(i > 0)
                html += `<button onclick="upLayer(${i})" title="Move layer to back" style="transform:rotate(90deg)"><</button>`;
            if(i < LAYERS.length-1)
                html += `<button onclick="downLayer(${i})" title="Move layer to front" style="transform:rotate(90deg)">></button>`
            html += `</div>`;
        });
        layerDiv.innerHTML = html;
    }

    function dotAtLayer(e,layer,clickX,clickY) {
        let cx = clickX-(START_X+layer.x);
        let cy = clickY-(START_Y+layer.y);
        if(cx < 0 || cx > layer.width || cy < 0 || cy > layer.height) // out of bounds
            return;

        if(!layer.showing) {
            layer.showing = true;
        } else {

            const color = COLORS[CURRENT_COLOR];
            let dSize = DRAW_SIZE*DOT_SIZE/P_SIZE;
            let x = Math.floor(cx/(DRAW_SIZE/(P_SIZE/DOT_SIZE)))*dSize;
            let y = Math.floor(cy/(DRAW_SIZE/(P_SIZE/DOT_SIZE)))*dSize;
            const map = `${x}_${y}_${dSize}_${color}`;
            if (e.shiftKey) {
                layer.commands.forEach((c,i)=>{
                    const parts = c[0].split("_").map(Number);
                    if(cx >= parts[0] && cx <= parts[0]+parts[2] && cy >= parts[1] && cy <= parts[1]+parts[2]) {
                        layer.commands.splice(i,1);
                        delete layer.map[c[0]];
                    }
                });
            } else {
                if(layer.map[map] != null) {
                    layer.commands.splice(layer.commands.findIndex(c=>c[0]==map&&c[1]==color),1);
                }
                layer.commands.push([map,color]);
                layer.map[map] = 1;
            }
        }

        drawCanvas();
    }

    function upLayer(i) {
        let layer = LAYERS.splice(i,1);
        LAYERS.splice(i-1,0,layer[0]);
        CURRENT_LAYER -= 1;
        buildLayerDiv();
    }
    function downLayer(i) {
        let layer = LAYERS.splice(i,1);
        LAYERS.splice(i+1,0,layer[0]);
        CURRENT_LAYER += 1;
        buildLayerDiv();
    }

    function layerSelected(i) {
        let layer = document.getElementById("layer_"+CURRENT_LAYER);
        if(layer != null)
            layer.classList.remove('selected');

        CURRENT_LAYER = i;
        layer = document.getElementById("layer_"+CURRENT_LAYER);
        layer.classList.add('selected');

        layerX.value = LAYERS[CURRENT_LAYER].x;
        layerY.value = LAYERS[CURRENT_LAYER].y;
        layerW.value = LAYERS[CURRENT_LAYER].w;
        layerH.value = LAYERS[CURRENT_LAYER].h;
        if(LAYERS[CURRENT_LAYER].blockWH)
            layerWH.innerHTML = "B";
        else
            layerWH.innerHTML = "U";

        if(typeof drawCanvas !== 'undefined')
            drawCanvas();
    }

    function buildColorDiv() {
        let html = "";
        COLORS.forEach((c,i)=>{
            html += `<div id="color_${i}" class="colorBox ${CURRENT_COLOR==i?'selected':''}" onclick="colorSelect(${i})" style="background:${c}"></div>`;
        });
        colorDiv.innerHTML = html;
    }

    function colorSelect(i) {
        CURRENT_COLOR = i;
        buildColorDiv();
    }

    function addColor() {
        const hex = prompt("Digite a cor:");
        if(hex != null) {
            COLORS.push(hex);
            CURRENT_COLOR = COLORS.length-1;
            buildColorDiv();
        }
    }

    buildLayerDiv();
    layerSelected(0);

    buildColorDiv();
</script>
<script>
    function buildPreview(previewSize,background=null) {
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = previewSize;
        previewCanvas.height = previewSize;
        const pctx = previewCanvas.getContext('2d');
        if(background != null) {
            pctx.fillStyle = background;
            pctx.fillRect(0,0,previewSize,previewSize);
        }
        let ratio = previewSize/DRAW_SIZE;

        LAYERS.forEach((l,i)=>{
            if(l.showing) {
                let vCanvas = document.createElement('canvas');
                vCanvas.width = l.w;
                vCanvas.height = l.h;
                let vctx = vCanvas.getContext('2d');
                drawLayer(vctx, l);
                pctx.drawImage(vCanvas,
                    0, 0, vCanvas.width, vCanvas.height,
                    l.x*ratio,l.y*ratio,vCanvas.width*ratio,vCanvas.height*ratio);
            }
        });

        return previewCanvas;
    }

    function drawCanvas() {
        canvasCtx.fillStyle = "#999";
        canvasCtx.fillRect(0,0,canvas.width,canvas.height);

        let x = START_X;
        let y = START_Y;

        canvasCtx.fillStyle = "#fff";
        canvasCtx.fillRect(x,y,DRAW_SIZE,DRAW_SIZE);

        drawBack();

        canvasCtx.save();
        canvasCtx.translate(START_X,START_Y);
        LAYERS.forEach((l,i)=>{
            if(l.showing) {
                let vCanvas = document.createElement('canvas');
                vCanvas.width = l.w;
                vCanvas.height = l.h;
                let vctx = vCanvas.getContext('2d');
                drawLayer(vctx, l, true, CURRENT_LAYER==i);
                canvasCtx.drawImage(vCanvas,l.x,l.y);
            }
        });
        canvasCtx.restore();

        drawGrid(x,y);

        let previewSize = 150;
        const previewCanvas = buildPreview(previewSize, "#aaa");
        canvasCtx.save();
        canvasCtx.translate(20,canvas.height-previewSize-20);
        canvasCtx.drawImage(previewCanvas,0,0);
        canvasCtx.restore();
    }

    function drawBack() {
        canvasCtx.globalAlpha = .6;
        canvasCtx.fillStyle = "#ddd";
        const size = DRAW_SIZE/13;
        let extra = 0;
        for(let x=START_X; x<START_X+DRAW_SIZE; x+=size) {
            for(let y=START_Y+extra; y<START_Y+DRAW_SIZE; y+=size*2) {
                canvasCtx.fillRect(x, y, Math.min(size,START_X+DRAW_SIZE-x), Math.min(size,START_Y+DRAW_SIZE-y));
            }
            if(extra == 0)
                extra = size;
            else
                extra = 0;
        }
        canvasCtx.globalAlpha = 1;
    }

    function drawGrid(xi,yi) {
        canvasCtx.strokeStyle = "red";
        canvasCtx.lineWidth = 0.5;

        let dSize = DRAW_SIZE*DOT_SIZE/P_SIZE;

        for (let x = xi; x <= xi+DRAW_SIZE; x += dSize) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(x, yi);
            canvasCtx.lineTo(x, yi+DRAW_SIZE);
            canvasCtx.stroke();
        }
        for (let y = yi; y <= yi+DRAW_SIZE; y += dSize) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(xi, y);
            canvasCtx.lineTo(xi+DRAW_SIZE, y);
            canvasCtx.stroke();
        }
    }

    function drawLayer(ctx, layer, border=false,highlight=false) {
        if(border) {
            if(highlight) {
                ctx.globalAlpha = 1;
            } else {
                ctx.globalAlpha = .8;
            }
        }

        if(layer.content) {
            ctx.drawImage(layer.content,
                0,0,layer.content.width,layer.content.height,
                0,0,layer.w,layer.h);
        }
        let lastColor = null;
        layer.commands.forEach(c => {
            if(lastColor == null || lastColor != c[1]) {
                lastColor = c[1];
                ctx.fillStyle=lastColor
            }
            const parts = c[0].split("_").map(Number);
            ctx.fillRect(parts[0],parts[1],parts[2],parts[2]);
        });
        ctx.globalAlpha = 1;
        if(border) {
            if(highlight) {
                ctx.strokeStyle = "#0f0";
                ctx.lineWidth = 4;
            } else {
                ctx.strokeStyle = "#00f";
                ctx.lineWidth = 2;
            }
            ctx.strokeRect(0,0,layer.w,layer.h);
        }
    }

    drawCanvas();

</script>
<script>
    var touchStartX = 0;
    var touchStartY = 0;
    var pressing = false;
    canvas.addEventListener('mousedown', (e) => {
        touchStartX = e.clientX;
        touchStartY = e.clientY;

        dotAtLayer(e,LAYERS[CURRENT_LAYER],touchStartX,touchStartY);
        pressing = true;
    });
    canvas.addEventListener('mousemove', (e) => {
        if(pressing) {
            touchStartX = e.clientX;
            touchStartY = e.clientY;

            dotAtLayer(e,LAYERS[CURRENT_LAYER],touchStartX,touchStartY);
        }
    });
    canvas.addEventListener('mouseup', (e) => {
        pressing = false;
    });

    document.addEventListener('keydown', function(event) {

        const isModifierKeyPressed = event.ctrlKey || event.metaKey;
        if (event.key === 'w' || event.key === 'W') {
            let color = Math.min(CURRENT_COLOR+1,COLORS.length-1);
            colorSelect(color);
        } else if (event.key === 'q' || event.key === 'Q') {
            let color = Math.max(CURRENT_COLOR-1,0);
            colorSelect(color);
        } else if(event.key === 'ArrowUp') {
            moveLayer(null,LAYERS[CURRENT_LAYER].y-DRAW_SIZE*DOT_SIZE/P_SIZE);
        } else if(event.key === 'ArrowDown') {
            moveLayer(null,LAYERS[CURRENT_LAYER].y+DRAW_SIZE*DOT_SIZE/P_SIZE);
        } else if(event.key === 'ArrowLeft') {
            moveLayer(LAYERS[CURRENT_LAYER].x-DRAW_SIZE*DOT_SIZE/P_SIZE,null);
        } else if(event.key === 'ArrowRight') {
            moveLayer(LAYERS[CURRENT_LAYER].x+DRAW_SIZE*DOT_SIZE/P_SIZE,null);
        } else if (event.key === 'n' || event.key === 'N') {
            addColor();
        } else if (event.key === 'a' || event.key === 'A') {
            dotSizeChanged(DOT_SIZE/2);
        } else if (event.key === 's' || event.key === 'S') {
            dotSizeChanged(DOT_SIZE*2);
        } else if (event.key === 'e' || event.key === 'E') {
            layerSelected(Math.max(0,CURRENT_LAYER-1));
        } else if (event.key === 'd' || event.key === 'D') {
            layerSelected(Math.min(LAYERS.length-1,CURRENT_LAYER+1));
        } else if (event.key === 'i' || event.key === 'I') {
            uploadImage();
        } else if(isModifierKeyPressed && (event.key === 'z' || event.key === 'Z')) {
            rewind();
        }

        let num = parseInt(event.key);
        if(isNaN(num) && event.key != 'Backspace' && !isModifierKeyPressed && event.key != 'shift' && event.key != 'r') {
            event.preventDefault();
            const inputs = document.querySelectorAll('input, button, select, textarea');
            inputs.forEach(element => {
                element.blur();
            });
        }

    });

    const FILE_READER = new FileReader();
    FILE_READER.onload = function(e) {
        var img = document.createElement("img");
        img.crossOrigin = 'anonymous';
        img.src = e.target.result;
        img.onload = function() {
            let vCanvas = document.createElement("canvas");
            vCanvas.width = img.width;
            vCanvas.height = img.height;
            let vCtx = vCanvas.getContext('2d');
            vCtx.drawImage(img,0,0);
            addLayer(vCanvas);
        }
    };

    function uploadImage() {
        let input = document.createElement('input');
        input.type = "file";
        input.accept = "image/png, image/gif, image/jpeg";
        input.addEventListener("change", (event) => {
            if(event.target.files[0])
                FILE_READER.readAsDataURL(event.target.files[0]);
        });
        input.click();
    }

    function savePNG() {
        const virtual_canvas = buildPreview(P_SIZE);

        const url = virtual_canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = url;
        a.download = 'desenho.png';
        a.click();
    }
</script>